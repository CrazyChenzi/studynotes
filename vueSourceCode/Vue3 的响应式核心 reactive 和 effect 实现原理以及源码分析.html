<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue3 的响应式核心 reactive 和 effect 实现原理以及源码分析 | StudyNotes</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" type="image/png" sizes="16x16" href="/studynotes/imgs/鸡尾酒.png">
    <meta name="description" content="CrazyChenzi&#39;s study notes, unlike blogs, are essays, only about code">
    
    <link rel="preload" href="/studynotes/assets/css/0.styles.b27df33a.css" as="style"><link rel="preload" href="/studynotes/assets/js/app.3d955cb7.js" as="script"><link rel="preload" href="/studynotes/assets/js/2.007e39c9.js" as="script"><link rel="preload" href="/studynotes/assets/js/1.02c32e63.js" as="script"><link rel="preload" href="/studynotes/assets/js/27.f89d87c6.js" as="script"><link rel="prefetch" href="/studynotes/assets/js/10.541f3cad.js"><link rel="prefetch" href="/studynotes/assets/js/11.c6588e7e.js"><link rel="prefetch" href="/studynotes/assets/js/12.918248b0.js"><link rel="prefetch" href="/studynotes/assets/js/13.bf000e6d.js"><link rel="prefetch" href="/studynotes/assets/js/14.1bac91e0.js"><link rel="prefetch" href="/studynotes/assets/js/15.1172bf50.js"><link rel="prefetch" href="/studynotes/assets/js/16.d211645d.js"><link rel="prefetch" href="/studynotes/assets/js/17.ecbf9cc6.js"><link rel="prefetch" href="/studynotes/assets/js/18.f646c752.js"><link rel="prefetch" href="/studynotes/assets/js/19.aba437c7.js"><link rel="prefetch" href="/studynotes/assets/js/20.4b4a7f9d.js"><link rel="prefetch" href="/studynotes/assets/js/21.8ee70ab5.js"><link rel="prefetch" href="/studynotes/assets/js/22.1489098c.js"><link rel="prefetch" href="/studynotes/assets/js/23.e6adf6f4.js"><link rel="prefetch" href="/studynotes/assets/js/24.130d023e.js"><link rel="prefetch" href="/studynotes/assets/js/25.831915f1.js"><link rel="prefetch" href="/studynotes/assets/js/26.e2e4e3d9.js"><link rel="prefetch" href="/studynotes/assets/js/3.ce2fe7f0.js"><link rel="prefetch" href="/studynotes/assets/js/4.0eb6d140.js"><link rel="prefetch" href="/studynotes/assets/js/5.bf6a3be0.js"><link rel="prefetch" href="/studynotes/assets/js/6.d295d44b.js"><link rel="prefetch" href="/studynotes/assets/js/7.bfd58751.js"><link rel="prefetch" href="/studynotes/assets/js/vendors~docsearch.4f1414c9.js">
    <link rel="stylesheet" href="/studynotes/assets/css/0.styles.b27df33a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/studynotes/" class="home-link router-link-active"><img src="/studynotes/imgs/鸡尾酒.svg" alt="StudyNotes" class="logo"> <span class="site-name can-hide">StudyNotes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue3.0 源码阅读</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html" class="sidebar-link">Vue3 Compiler 优化细节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#block、block-tree-和-patchflags-是什么" class="sidebar-link">Block、Block Tree 和 PatchFlags 是什么</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#block-vnode-是如何创建的" class="sidebar-link">Block VNode 是如何创建的</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#block-配合-patchflags-做到靶向更新" class="sidebar-link">Block 配合 PatchFlags 做到靶向更新</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#不稳定的-block-tree" class="sidebar-link">不稳定的 Block Tree</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#静态提升" class="sidebar-link">静态提升</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#cache-event-handler" class="sidebar-link">Cache Event handler</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 Compiler 优化细节.html#参考" class="sidebar-link">参考：</a></li></ul></li><li><a href="/studynotes/vueSourceCode/从 compile 和 runtime 来看组件的第一次 patch.html" class="sidebar-link">从 compile 和 runtime 来看组件的第一次 patch</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 compile 和 runtime 来看组件的第一次 patch.html#什么是-shapflag" class="sidebar-link">什么是 shapFlag</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 compile 和 runtime 来看组件的第一次 patch.html#组件的创建过程" class="sidebar-link">组件的创建过程</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 compile 和 runtime 来看组件的第一次 patch.html#patch-对组件的处理" class="sidebar-link">patch 对组件的处理</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 compile 和 runtime 来看组件的第一次 patch.html#总结" class="sidebar-link">总结：</a></li></ul></li><li><a href="/studynotes/vueSourceCode/从 patch 方法来看 diff 算法.html" class="sidebar-link">从 patch 方法来看 diff 算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 patch 方法来看 diff 算法.html#副作用函数更新组件的过程" class="sidebar-link">副作用函数更新组件的过程</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 patch 方法来看 diff 算法.html#patch-流程" class="sidebar-link">patch 流程</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 patch 方法来看 diff 算法.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/从 patch 方法来看 diff 算法.html#拓展" class="sidebar-link">拓展</a></li></ul></li><li><a href="/studynotes/vueSourceCode/Vue3 源码解读之 teleport.html" class="sidebar-link">Vue3 源码解读之 teleport</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 源码解读之 teleport.html#源码分析" class="sidebar-link">源码分析</a></li></ul></li><li><a href="/studynotes/vueSourceCode/Vue3 的响应式核心 reactive 和 effect 实现原理以及源码分析.html" class="active sidebar-link">Vue3 的响应式核心 reactive 和 effect 实现原理以及源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 的响应式核心 reactive 和 effect 实现原理以及源码分析.html#reactive-和-effect" class="sidebar-link">reactive 和 effect</a></li><li class="sidebar-sub-header"><a href="/studynotes/vueSourceCode/Vue3 的响应式核心 reactive 和 effect 实现原理以及源码分析.html#源码" class="sidebar-link">源码</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue3-的响应式核心-reactive-和-effect-实现原理以及源码分析"><a href="#vue3-的响应式核心-reactive-和-effect-实现原理以及源码分析" class="header-anchor">#</a> Vue3 的响应式核心 reactive 和 effect 实现原理以及源码分析</h1> <h2 id="reactive-和-effect"><a href="#reactive-和-effect" class="header-anchor">#</a> reactive 和 effect</h2> <p>Vue3 的响应式系统通过官网的 API 可以看到有很多，例如 ref、computed、reactive、readonly、watchEffect、watch 等等，这些都是 Vue3 的响应式系统的一部分</p> <h3 id="reactive"><a href="#reactive" class="header-anchor">#</a> reactive</h3> <p><a href="https://cn.vuejs.org/api/reactivity-core.html#reactive" target="_blank" rel="noopener noreferrer">reactive<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>reactive 根据官网的介绍，有如下特点：</p> <ul><li>接收一个普通对象，返回一个响应式的代理对象</li> <li>响应式的对象是深层的，会影响对象内部所有嵌套的属性</li> <li>会自动对ref对象进行解包</li> <li>对于数组、对象、Map、Set等原生类型中的元素，如果是ref对象不会自动解包</li> <li>返回的对象会通过Proxy进行包装，所以不等于原始对象</li></ul> <h3 id="effect"><a href="#effect" class="header-anchor">#</a> effect</h3> <blockquote><p>effect在官网上是没有提到这个API的，但是在源码中是有的，并且我们也是可以直接使用，如下代码所示：</p></blockquote> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> effect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

data<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>通常情况下我们是不会直接使用effect的，因为effect是一个底层的API，在我们使用Vue3的时候Vue默认会帮我们调用effect，所以我们的关注点通常都是在reactive上。</p> <p>但是reactive需要和effect配合使用才会有响应式的效果，所以我们需要了解一下effect的作用。</p> <p>effect直接翻译为作用，意思是使其发生作用，这个使其的其就是我们传入的函数，所以effect的作用就是让我们传入的函数发生作用，也就是执行这个函数。</p> <p>但是 effect 具体是怎么执行的呢？</p> <h2 id="源码"><a href="#源码" class="header-anchor">#</a> 源码</h2> <p>源码位置：packages/reactivity</p> <blockquote><p>Built-in objects are not observed except for <code>Array</code>, <code>Map</code>, <code>WeakMap</code>, <code>Set</code> and <code>WeakSet</code>.</p></blockquote> <p>响应式系统出了对 <code>Array</code>、<code>Map</code>、<code>WeakMap</code>、<code>Set</code> 和 <code>WeakSet</code> 这些原生类型进行了响应式处理，对其他的原生类型，例如 <code>Date</code>、<code>RegExp</code>、<code>Error</code> 等等，都没有进行响应式处理。</p> <h3 id="reactive-2"><a href="#reactive-2" class="header-anchor">#</a> reactive</h3> <p>源码位置： packages/reactivity/src/reactive.ts</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span>target<span class="token operator">:</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// if trying to observe a readonly proxy, return the readonly version.</span>
  <span class="token comment">// 如果对只读的代理对象进行再次代理，那么应该返回原始的只读代理对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReadonly</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token comment">// 通过 createReactiveObject 方法创建响应式对象</span>
  <span class="token keyword">return</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>
    target<span class="token punctuation">,</span>
    <span class="token boolean">false</span><span class="token punctuation">,</span>
    mutableHandlers<span class="token punctuation">,</span>
    mutableCollectionHandlers<span class="token punctuation">,</span>
    reactiveMap
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>reactive的源码很简单，就是调用了createReactiveObject方法，这个方法是一个工厂方法，用来创建响应式对象的，我们来看看这个方法的源码。</p> <h3 id="createreactiveobject"><a href="#createreactiveobject" class="header-anchor">#</a> createReactiveObject</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>
  target<span class="token operator">:</span> Target<span class="token punctuation">,</span>
  isReadonly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span>
  baseHandlers<span class="token operator">:</span> ProxyHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  collectionHandlers<span class="token operator">:</span> ProxyHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  proxyMap<span class="token operator">:</span> WeakMap<span class="token operator">&lt;</span>Target<span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果 target 不是对象，那么直接返回 target</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">value cannot be made reactive: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">String</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token comment">// target is already a Proxy, return it.</span>
  <span class="token comment">// exception: calling readonly() on a reactive object</span>
  <span class="token comment">// 如果 target 已经是一个代理对象了，那么直接返回 target</span>
  <span class="token comment">// 异常：如果对一个响应式对象调用 readonly() 方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    target<span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">RAW</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token punctuation">(</span>isReadonly <span class="token operator">&amp;&amp;</span> target<span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_REACTIVE</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token comment">// target already has corresponding Proxy</span>
  <span class="token comment">// 如果 target 已经有对应的代理对象了，那么直接返回代理对象</span>
  <span class="token keyword">const</span> existingProxy <span class="token operator">=</span> proxyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>existingProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> existingProxy
  <span class="token punctuation">}</span>
  <span class="token comment">// only specific value types can be observed.</span>
  <span class="token comment">// 对于不能被观察的类型，直接返回 target</span>
  <span class="token keyword">const</span> targetType <span class="token operator">=</span> <span class="token function">getTargetType</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>targetType <span class="token operator">===</span> TargetType<span class="token punctuation">.</span><span class="token constant">INVALID</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建一个响应式对象</span>
  <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>
    target<span class="token punctuation">,</span>
    targetType <span class="token operator">===</span> TargetType<span class="token punctuation">.</span><span class="token constant">COLLECTION</span> <span class="token operator">?</span> collectionHandlers <span class="token operator">:</span> baseHandlers
  <span class="token punctuation">)</span>
  <span class="token comment">// 将 target 和 proxy 保存到 proxyMap 中</span>
  proxyMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> proxy<span class="token punctuation">)</span>
  <span class="token keyword">return</span> proxy
<span class="token punctuation">}</span>
</code></pre></div><p>createReactiveObject方法的源码也很简单，最开始的一些代码都是对需要代理的target进行一些判断，判断的边界都是target不是对象的情况和target已经是一个代理对象的情况；</p> <p>其中的核心的代码主要是最后七行代码：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>
  target<span class="token operator">:</span> Target<span class="token punctuation">,</span>
  isReadonly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span>
  baseHandlers<span class="token operator">:</span> ProxyHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  collectionHandlers<span class="token operator">:</span> ProxyHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  proxyMap<span class="token operator">:</span> WeakMap<span class="token operator">&lt;</span>Target<span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// only specific value types can be observed.</span>
  <span class="token comment">// 对于不能被观察的类型，直接返回 target</span>
  <span class="token keyword">const</span> targetType <span class="token operator">=</span> <span class="token function">getTargetType</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>targetType <span class="token operator">===</span> TargetType<span class="token punctuation">.</span><span class="token constant">INVALID</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建一个响应式对象</span>
  <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>
    target<span class="token punctuation">,</span>
    targetType <span class="token operator">===</span> TargetType<span class="token punctuation">.</span><span class="token constant">COLLECTION</span> <span class="token operator">?</span> collectionHandlers <span class="token operator">:</span> baseHandlers
  <span class="token punctuation">)</span>
  <span class="token comment">// 将 target 和 proxy 保存到 proxyMap 中</span>
  proxyMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> proxy<span class="token punctuation">)</span>
  <span class="token keyword">return</span> proxy
<span class="token punctuation">}</span>
</code></pre></div><p>这里有一个targetType的判断，那么这个targetType是什么呢？我们来看看getTargetType方法的源码：</p> <h4 id="gettargettype"><a href="#gettargettype" class="header-anchor">#</a> getTargetType</h4> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">targetTypeMap</span><span class="token punctuation">(</span>rawType<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>rawType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'Object'</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token string">'Array'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> TargetType<span class="token punctuation">.</span><span class="token constant">COMMON</span>
    <span class="token keyword">case</span> <span class="token string">'Map'</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token string">'Set'</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token string">'WeakMap'</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token string">'WeakSet'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> TargetType<span class="token punctuation">.</span><span class="token constant">COLLECTION</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> TargetType<span class="token punctuation">.</span><span class="token constant">INVALID</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getTargetType</span><span class="token punctuation">(</span>value<span class="token operator">:</span> Target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value<span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">SKIP</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span>Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token operator">?</span> TargetType<span class="token punctuation">.</span><span class="token constant">INVALID</span>
    <span class="token operator">:</span> <span class="token function">targetTypeMap</span><span class="token punctuation">(</span><span class="token function">toRawType</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> TargetType <span class="token punctuation">{</span>
  <span class="token constant">INVALID</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 无效的数据类型，对应的值是 0，表示 Vue 不会对这种类型的数据进行响应式处理</span>
  <span class="token constant">COMMON</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 普通的数据类型，对应的值是 1，表示 Vue 会对这种类型的数据进行响应式处理</span>
  <span class="token constant">COLLECTION</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 集合类型，对应的值是 2，表示 Vue 会对这种类型的数据进行响应式处理</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token keyword">enum</span> ReactiveFlags <span class="token punctuation">{</span>
  <span class="token constant">SKIP</span> <span class="token operator">=</span> <span class="token string">'__v_skip'</span><span class="token punctuation">,</span> <span class="token comment">// 用于标识一个对象是否不可被转为代理对象，对应的值是 __v_skip</span>
  <span class="token constant">IS_REACTIVE</span> <span class="token operator">=</span> <span class="token string">'__v_isReactive'</span><span class="token punctuation">,</span> <span class="token comment">// 用于标识一个对象是否是响应式的代理，对应的值是 __v_isReactive</span>
  <span class="token constant">IS_READONLY</span> <span class="token operator">=</span> <span class="token string">'__v_isReadonly'</span><span class="token punctuation">,</span> <span class="token comment">// 用于标识一个对象是否是只读的代理，对应的值是 __v_isReadonly</span>
  <span class="token constant">IS_SHALLOW</span> <span class="token operator">=</span> <span class="token string">'__v_isShallow'</span><span class="token punctuation">,</span> <span class="token comment">// 用于标识一个对象是否是浅层代理，对应的值是 __v_isShallow</span>
  <span class="token constant">RAW</span> <span class="token operator">=</span> <span class="token string">'__v_raw'</span> <span class="token comment">// 用于保存原始对象的 key，对应的值是 __v_raw</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="collectionhandlers-basehandlers"><a href="#collectionhandlers-basehandlers" class="header-anchor">#</a> collectionHandlers &amp; baseHandlers</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 创建一个响应式对象</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>
  target<span class="token punctuation">,</span>
  targetType <span class="token operator">===</span> TargetType<span class="token punctuation">.</span><span class="token constant">COLLECTION</span> <span class="token operator">?</span> collectionHandlers <span class="token operator">:</span> baseHandlers
<span class="token punctuation">)</span>
</code></pre></div><p>targetType 根据枚举值也就只有3个值，最后走向代理的也就只有两种情况：</p> <ul><li>targetType为1的时候，这个时候target是一个普通的对象或者数组，这个时候使用baseHandlers</li> <li>targetType为2的时候，这个时候target是一个集合类型，这个时候使用collectionHandlers</li></ul> <p>而这两个 handler 是通过外部传入的，也就是 createReactiveObject 的第三第四个参数。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span>target<span class="token operator">:</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// if trying to observe a readonly proxy, return the readonly version.</span>
  <span class="token comment">// 如果对只读的代理对象进行再次代理，那么应该返回原始的只读代理对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReadonly</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token comment">// 通过 createReactiveObject 方法创建响应式对象</span>
  <span class="token keyword">return</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>
    target<span class="token punctuation">,</span>
    <span class="token boolean">false</span><span class="token punctuation">,</span>
    mutableHandlers<span class="token punctuation">,</span>
    mutableCollectionHandlers<span class="token punctuation">,</span>
    reactiveMap
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="basehandler"><a href="#basehandler" class="header-anchor">#</a> baseHandler</h4> <p>源码位置： packages/reactivity/src/baseHandlers.ts</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">const</span> mutableHandlers<span class="token operator">:</span> ProxyHandler<span class="token operator">&lt;</span>object<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  get<span class="token punctuation">,</span>
  set<span class="token punctuation">,</span>
  deleteProperty<span class="token punctuation">,</span>
  has<span class="token punctuation">,</span>
  ownKeys
<span class="token punctuation">}</span>
</code></pre></div><p>这里分别定义了 get、set、deleteProperty、has、ownKeys 这几个方法拦截器</p> <ul><li>get：拦截对象的getter操作，比如obj.name；</li> <li>set：拦截对象的setter操作，比如obj.name = 'zhangsan'；</li> <li>deleteProperty：拦截delete操作，比如delete obj.name；</li> <li>has：拦截in操作，比如'name' in obj；</li> <li>ownKeys：拦截Object.getOwnPropertyNames、Object.getOwnPropertySymbols、Object.keys等操作；</li></ul> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy" target="_blank" rel="noopener noreferrer">详细<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>接下来我们看一下这些拦截器的具体实现</p> <h5 id="get"><a href="#get" class="header-anchor">#</a> get</h5> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createGetter</span><span class="token punctuation">(</span>isReadonly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> shallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token operator">:</span> Target<span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">,</span> receiver<span class="token operator">:</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_REACTIVE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 代理 observer.__v_isReactive</span>
      <span class="token keyword">return</span> <span class="token operator">!</span>isReadonly
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_READONLY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 代理 observer.__v_isReadonly</span>
      <span class="token keyword">return</span> isReadonly
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_SHALLOW</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 代理 observer.__v_isShallow</span>
      <span class="token keyword">return</span> shallow
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token comment">// 代理 observer.__v_raw</span>
      key <span class="token operator">===</span> ReactiveFlags<span class="token punctuation">.</span><span class="token constant">RAW</span> <span class="token operator">&amp;&amp;</span>
      receiver <span class="token operator">===</span>
        <span class="token punctuation">(</span>isReadonly
          <span class="token operator">?</span> shallow
            <span class="token operator">?</span> shallowReadonlyMap
            <span class="token operator">:</span> readonlyMap
          <span class="token operator">:</span> shallow
          <span class="token operator">?</span> shallowReactiveMap
          <span class="token operator">:</span> reactiveMap
        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> target
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> targetIsArray <span class="token operator">=</span> <span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// arrayInstrumentations 包含对数组一些方法修改的函数</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>targetIsArray <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>arrayInstrumentations<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>arrayInstrumentations<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'hasOwnProperty'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> hasOwnProperty
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 求值</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// 内置 Sysbol key 不需要依赖收集</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSymbol</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">?</span> builtInSymbols<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">isNonTrackableKeys</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReadonly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 依赖收集</span>
      <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> TrackOpTypes<span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>shallow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ref unwrapping - skip unwrap for Array + integer key.</span>
      <span class="token keyword">return</span> targetIsArray <span class="token operator">&amp;&amp;</span> <span class="token function">isIntegerKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">?</span> res <span class="token operator">:</span> res<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Convert returned value into a proxy as well. we do the isObject check</span>
      <span class="token comment">// here to avoid invalid value warning. Also need to lazy access readonly</span>
      <span class="token comment">// and reactive here to avoid circular dependency.</span>
      <span class="token comment">// 如果返回的值是对象,那么将其转为代理对象</span>
      <span class="token keyword">return</span> isReadonly <span class="token operator">?</span> <span class="token keyword">readonly</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上述代码来看， get 函数主要做了四件事情，<strong>首先对特殊 key 做了代理</strong>，就比如我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</p> <p><strong>接着通过 Reflect.get 方法求值</strong>，如果 target 是数组并且 key 命中的 arrayInstrumentations, 则执行对应的函数。</p> <p><strong>arrayInstrumentations 实现</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createArrayInstrumentations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instrumentations<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// instrument identity-sensitive Array methods to account for possible reactive</span>
  <span class="token comment">// values</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'includes'</span><span class="token punctuation">,</span> <span class="token string">'indexOf'</span><span class="token punctuation">,</span> <span class="token string">'lastIndexOf'</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    instrumentations<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// toRaw 可以把响应式对象转成原始数据</span>
      <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">toRaw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">any</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 依赖收集</span>
        <span class="token function">track</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> TrackOpTypes<span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// we run the method using the original args first (which may be reactive)</span>
      <span class="token comment">// 先尝试用参数本身，可能是响应式数据</span>
      <span class="token keyword">const</span> res <span class="token operator">=</span> arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> res <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// if that didn't work, run it again using raw values.</span>
        <span class="token comment">// 如果失败，再尝试把参数转成原始数据</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toRaw<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> res
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// instrument length-altering mutation methods to avoid length being tracked</span>
  <span class="token comment">// which leads to infinite loops in some cases (#2137)</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'push'</span><span class="token punctuation">,</span> <span class="token string">'pop'</span><span class="token punctuation">,</span> <span class="token string">'shift'</span><span class="token punctuation">,</span> <span class="token string">'unshift'</span><span class="token punctuation">,</span> <span class="token string">'splice'</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    instrumentations<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">pauseTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">toRaw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      <span class="token function">resetTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> instrumentations
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，当 target 为一个数组的时候，我们去访问 target.includes、target.indexOf 或者 target.lastIndexOf 就会执行 arrayInstrumentations 的代理函数。整个 get 函数最核心的部分就是 <strong>执行 track 函数收集依赖</strong></p> <h5 id="set"><a href="#set" class="header-anchor">#</a> set</h5> <p>源码位置：packages/reactivity/src/baseHandlers.ts</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createSetter</span><span class="token punctuation">(</span>shallow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span>
    target<span class="token operator">:</span> object<span class="token punctuation">,</span>
    key<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">,</span>
    value<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span>
    receiver<span class="token operator">:</span> object
  <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取旧值</span>
    <span class="token keyword">let</span> oldValue <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token comment">// 如果旧值是只读的，并且是 ref，并且新值不是 ref，那么直接返回 false，代表设置失败</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReadonly</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRef</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRef</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shallow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isShallow</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isReadonly</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldValue <span class="token operator">=</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span> <span class="token comment">// 获取旧值的原始值</span>
        value <span class="token operator">=</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 获取新值的原始值</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果目标对象不是数组，并且旧值是 ref，并且新值不是 ref，那么设置旧值的 value 为新值，并且返回 true，代表设置成功</span>
      <span class="token comment">// ref 的值是在 value 属性上的，这里判断了旧值的代理类型，所以设置到了旧值的 value 上</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRef</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRef</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldValue<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token keyword">return</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// in shallow mode, objects are set as-is regardless of reactive or not</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果是数组，并且 key 是整数类型</span>
    <span class="token keyword">const</span> hadKey <span class="token operator">=</span>
      <span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isIntegerKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token comment">// 如果 key 小于数组的长度，那么就是有这个 key</span>
        <span class="token operator">?</span> <span class="token function">Number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">.</span>length
        <span class="token comment">// 如果不是数组，那么就是普通对象，直接判断是否有这个 key</span>
        <span class="token operator">:</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 通过 Reflect.set 设置值</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token comment">// don't trigger if target is something up in the prototype chain of original</span>
    <span class="token comment">// 如果目标对象是原始数据的原型链中的某个元素，则不会触发依赖收集</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果没有这个 key，那么就是新增了一个属性，触发 add 事件</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hadKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">ADD</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasChanged</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果有这个 key，那么就是修改了一个属性，触发 set 事件</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">SET</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回结果，这个结果为 boolean 类型，代表是否设置成功</span>
    <span class="token comment">// 只是代理相关，，和业务无关，必须要返回是否设置成功的结果</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>set 函数主要做了两件事情，通过 Reflect.set 求值，通过 trigger 函数派发通知，并根据 key 是否存在于 target 上来确定通知类型，即新增还是修改。整个 set 函数最核心的就是 <strong>trigger 函数派发通知</strong>。</p> <h4 id="effect-函数"><a href="#effect-函数" class="header-anchor">#</a> effect 函数</h4> <p>上面讲完了reactive方法，接下来就是effect方法，effect方法的作用是创建一个副作用函数，这个函数会在依赖的数据发生变化的时候执行；</p> <p>依赖收集和触发更新的过程先不要着急，等讲完effect方法之后，再来分析这个过程，先看看effect方法的实现：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">effect</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span><span class="token operator">:</span> ReactiveEffectOptions
<span class="token punctuation">)</span><span class="token operator">:</span> ReactiveEffectRunner <span class="token punctuation">{</span>
  <span class="token comment">// 如果 fn 对象上有 effect 属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token keyword">as</span> ReactiveEffectRunner<span class="token punctuation">)</span><span class="token punctuation">.</span>effect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 那么就将 fn 替换为 fn.effect.fn</span>
    fn <span class="token operator">=</span> <span class="token punctuation">(</span>fn <span class="token keyword">as</span> ReactiveEffectRunner<span class="token punctuation">)</span><span class="token punctuation">.</span>effect<span class="token punctuation">.</span>fn
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建一个响应式副作用函数</span>
  <span class="token keyword">const</span> _effect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveEffect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token comment">// 如果有配置项</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将配置项合并到响应式副作用函数上</span>
    <span class="token function">extend</span><span class="token punctuation">(</span>_effect<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token comment">// 如果配置项中有 scope 属性（该属性的作用是指定副作用函数的作用域）</span>
    <span class="token comment">// 那么就将 scope 属性记录到响应式副作用函数上（类似一个作用域链）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>scope<span class="token punctuation">)</span> <span class="token function">recordEffectScope</span><span class="token punctuation">(</span>_effect<span class="token punctuation">,</span> options<span class="token punctuation">.</span>scope<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果没有配置项，或者配置项中没有 lazy 属性，或者配置项中的 lazy 属性为 false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options <span class="token operator">||</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 那么就执行响应式副作用函数</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 _effect.run 的 this 指向 _effect</span>
  <span class="token keyword">const</span> runner <span class="token operator">=</span> _effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>_effect<span class="token punctuation">)</span> <span class="token keyword">as</span> ReactiveEffectRunner
  <span class="token comment">// 将响应式副作用函数赋值给 runner.effect</span>
  runner<span class="token punctuation">.</span>effect <span class="token operator">=</span> _effect
  <span class="token keyword">return</span> runner
<span class="token punctuation">}</span>
</code></pre></div><p>这里的关键点有两个部分</p> <ul><li>创建一个响应式副作用函数const _effect = new ReactiveEffect(fn)</li> <li>返回一个runner函数，可以通过这个函数来执行响应式副作用函数</li></ul> <h4 id="reactiveeffect"><a href="#reactiveeffect" class="header-anchor">#</a> ReactiveEffect</h4> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">constructor</span><span class="token punctuation">(</span>
  <span class="token keyword">public</span> <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token comment">// 副作用函数</span>
  <span class="token keyword">public</span> scheduler<span class="token operator">:</span> EffectScheduler <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 调度器，用于控制副作用函数何时执行</span>
  scope<span class="token operator">?</span><span class="token operator">:</span> EffectScope
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">recordEffectScope</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> scope<span class="token punctuation">)</span> <span class="token comment">// 记录当前 ReactiveEffect 对象的作用域</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ReactiveEffect这个类的实现主要体现在两个方法上，一个是run方法，一个是stop方法；</p> <p>其他的属性都是用来记录一些数据的，比如fn属性就是用来记录副作用函数的，scheduler属性就是用来记录调度器的，active属性就是用来记录当前ReactiveEffect对象是否处于活动状态的；</p> <p><strong>run</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果当前 ReactiveEffect 对象不处于活动状态，直接返回 fn 的执行结果</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 寻找当前 ReactiveEffect 对象的最顶层的父级作用域</span>
  <span class="token keyword">let</span> parent<span class="token operator">:</span> ReactiveEffect <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> activeEffect
  <span class="token keyword">let</span> lastShouldTrack <span class="token operator">=</span> shouldTrack
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>parent
  <span class="token punctuation">}</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录父级作用域为当前活动的 ReactiveEffect 对象</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> activeEffect
    <span class="token comment">// 将当前活动的 ReactiveEffect 对象设置为 “自己”</span>
    activeEffect <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// 将 shouldTrack 设置为 true （表示是否需要收集依赖）</span>
    shouldTrack <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// effectTrackDepth 用于标识当前的 effect 调用栈的深度，执行一次 effect 就会将 effectTrackDepth 加 1</span>
    trackOpBit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>effectTrackDepth
    <span class="token comment">// 这里是用于控制 &quot;effect调用栈的深度&quot; 在一个阈值之内</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTrackDepth <span class="token operator">&lt;=</span> maxMarkerBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始依赖追踪标记</span>
      <span class="token function">initDepMarkers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 清除所有的依赖追踪标记</span>
      <span class="token function">cleanupEffect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 执行副作用函数，并返回执行结果</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 effect调用栈的深度 没有超过阈值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTrackDepth <span class="token operator">&lt;=</span> maxMarkerBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 确定最终的依赖追踪标记</span>
      <span class="token function">finalizeDepMarkers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 执行完毕会将 effectTrackDepth 减 1</span>
    trackOpBit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">--</span>effectTrackDepth
    <span class="token comment">// 执行完毕，将当前活动的 ReactiveEffect 对象设置为 “父级作用域”</span>
    activeEffect <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parent
    <span class="token comment">// 将 shouldTrack 设置为上一个值</span>
    shouldTrack <span class="token operator">=</span> lastShouldTrack
    <span class="token comment">// 将父级作用域设置为 undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// 延时停止，这个标志是在 stop 方法中设置的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>deferStop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>整体梳理下来，run方法的作用就是执行副作用函数，并且在执行副作用函数的过程中，会收集依赖</p> <p>整体的流程还是非常复杂的，但是这里的核心思想是各种标识位的设置，以及在执行副作用函数的过程中，会收集依赖</p> <p><strong>stop</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// stopped while running itself - defer the cleanup</span>
  <span class="token comment">// 如果当前 活动的 ReactiveEffect 对象是 “自己”</span>
  <span class="token comment">// 延迟停止，需要执行完当前的副作用函数之后再停止</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 run 方法中会判断 deferStop 的值，如果为 true，就会执行 stop 方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>deferStop <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前 ReactiveEffect 对象处于活动状态</span>
    <span class="token function">cleanupEffect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 清除所有的依赖追踪标记</span>
    <span class="token comment">// 如果有 onStop 回调函数，就执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onStop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将 active 设置为 false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>stop方法的作用就是停止当前的ReactiveEffect对象，停止之后，就不会再收集依赖了</p> <p>这里的activeEffect和this并不是每次都相等的，因为activeEffect会跟着调用栈的深度而变化，而this则是固定的</p> <p>this.active标识的自身是否处在活动状态，因为嵌套的ReactiveEffect对象，activeEffect并不一定指向自己，而this.active则是自身的状态</p> <h4 id="依赖收集"><a href="#依赖收集" class="header-anchor">#</a> 依赖收集</h4> <h5 id="track-函数"><a href="#track-函数" class="header-anchor">#</a> track 函数</h5> <p>源码位置：packages/reactivity/src/effect.ts</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token operator">:</span> object<span class="token punctuation">,</span> type<span class="token operator">:</span> TrackOpTypes<span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果 shouldTrack 为 false，并且 activeEffect 没有值的话，就不会收集依赖</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrack <span class="token operator">&amp;&amp;</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 targetMap 中没有 target，就会创建一个 Map</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      targetMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果 depsMap 中没有 key，就会创建一个 Set</span>
    <span class="token keyword">let</span> dep <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>dep <span class="token operator">=</span> <span class="token function">createDep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> eventInfo <span class="token operator">=</span> __DEV__
      <span class="token operator">?</span> <span class="token punctuation">{</span> effect<span class="token operator">:</span> activeEffect<span class="token punctuation">,</span> target<span class="token punctuation">,</span> type<span class="token punctuation">,</span> key <span class="token punctuation">}</span>
      <span class="token operator">:</span> <span class="token keyword">undefined</span>

    <span class="token comment">// 如果 dep 中没有当前的 ReactiveEffect 对象，就会添加进去</span>
    <span class="token function">trackEffects</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> eventInfo<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里我们发现了两个老熟人，一个是shouldTrack，一个是activeEffect，这两个变量都是在effect方法中出现过的；</p> <p>shouldTrack在上面也讲过，它的作用就是控制是否收集依赖</p> <p>activeEffect就是我们刚刚讲的ReactiveEffect对象，它指向的就是当前正在执行的副作用函数；</p> <p>track方法的作用就是收集依赖，它的实现非常简单，就是在targetMap中记录下target和key；</p> <p>targetMap是一个WeakMap，它的键是target，值是一个Map，这个Map的键是key，值是一个Set；</p> <p>这意味着，如果我们在操作target的key时，就会收集依赖，这个时候，target和key就会被记录到targetMap中</p> <h5 id="trigger函数的实现"><a href="#trigger函数的实现" class="header-anchor">#</a> trigger函数的实现</h5> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>
  target<span class="token operator">:</span> object<span class="token punctuation">,</span>
  type<span class="token operator">:</span> TriggerOpTypes<span class="token punctuation">,</span>
  key<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span>
  newValue<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span>
  oldValue<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span>
  oldTarget<span class="token operator">?</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">&gt;</span> <span class="token operator">|</span> Set<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 通过 targetMap 获取 target 对应的 depsMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// never been tracked</span>
    <span class="token comment">// 没有依赖，直接返回</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建一个数组，用来存放需要执行的 ReactiveEffect 对象</span>
  <span class="token keyword">let</span> deps<span class="token operator">:</span> <span class="token punctuation">(</span>Dep <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 如果 type 为 clear，就会将 depsMap 中的所有 ReactiveEffect 对象都添加到 deps 中</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">CLEAR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// collection being cleared</span>
    <span class="token comment">// trigger all effects for target</span>
    <span class="token comment">// 执行所有的 副作用函数</span>
    deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>depsMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'length'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果 key 为 length ，并且 target 是一个数组</span>
    <span class="token comment">// 修改数组的长度，会导致数组的索引发生变化</span>
    <span class="token comment">// 但是只有两种情况，一种是数组的长度变大，一种是数组的长度变小</span>
    <span class="token comment">// 如果数组的长度变大，那么执行所有的副作用函数就可以了</span>
    <span class="token comment">// 如果数组的长度变小，那么就需要执行索引大于等于新数组长度的副作用函数</span>
    <span class="token keyword">const</span> newLength <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>
    depsMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'length'</span> <span class="token operator">||</span> key <span class="token operator">&gt;=</span> newLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// schedule runs for SET | ADD | DELETE</span>
    <span class="token comment">// key 不是 undefined，就会将 depsMap 中 key 对应的 ReactiveEffect 对象添加到 deps 中</span>
    <span class="token comment">// void 0 就是 undefined</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// also run for iteration key on ADD | DELETE | Map.SET</span>
    <span class="token comment">// 执行 add、delete、set 操作时，就会触发的依赖变更</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 type 为 add，就会触发的依赖变更</span>
      <span class="token keyword">case</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">ADD</span><span class="token operator">:</span>
        <span class="token comment">// 如果 target 不是数组，就会触发迭代器</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// ITERATE_KEY 再上面介绍过，用来标识迭代属性</span>
          <span class="token comment">// 例如：for...in、for...of，这个时候依赖会收集到 ITERATE_KEY 上</span>
          <span class="token comment">// 而不是收集到具体的 key 上</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token comment">// 如果 target 是一个 Map，就会触发 MAP_KEY_ITERATE_KEY</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// MAP_KEY_ITERATE_KEY 同上面的 ITERATE_KEY 一样</span>
            <span class="token comment">// 不同的是，它是用来标识 Map 的迭代器</span>
            <span class="token comment">// 例如：Map.prototype.keys()、Map.prototype.values()、Map.prototype.entries()</span>
            deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">MAP_KEY_ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isIntegerKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果 key 是一个数字，就会触发 length 依赖</span>
          <span class="token comment">// new index added to array -&gt; length changes</span>
          <span class="token comment">// 因为数组的索引是可以通过 arr[0] 这种方式来访问的</span>
          <span class="token comment">// 也可以通过这种方式来修改数组的值，所以会触发 length 依赖</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'length'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
      <span class="token comment">// 如果 type 为 delete，就会触发的依赖变更</span>
      <span class="token keyword">case</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">DELETE</span><span class="token operator">:</span>
        <span class="token comment">// 如果 target 不是数组，就会触发迭代器，同上面的 add 操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">MAP_KEY_ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
      <span class="token comment">// 如果 type 为 set，就会触发的依赖变更</span>
      <span class="token keyword">case</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">SET</span><span class="token operator">:</span>
        <span class="token comment">// 如果 target 是一个 Map，就会触发迭代器，同上面的 add 操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> eventInfo <span class="token operator">=</span> __DEV__
    <span class="token operator">?</span> <span class="token punctuation">{</span> target<span class="token punctuation">,</span> type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> oldTarget <span class="token punctuation">}</span>
    <span class="token operator">:</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 如果 deps 的长度为 1，就会直接执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">triggerEffects</span><span class="token punctuation">(</span>deps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> eventInfo<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">triggerEffects</span><span class="token punctuation">(</span>deps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 deps 的长度大于 1，这个时候会组装成一个数组，然后再执行</span>
    <span class="token comment">// 这个时候调用就类似一个调用栈</span>
    <span class="token keyword">const</span> effects<span class="token operator">:</span> ReactiveEffect<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> dep <span class="token keyword">of</span> deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        effects<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>dep<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffects</span><span class="token punctuation">(</span><span class="token function">createDep</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span><span class="token punctuation">,</span> eventInfo<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffects</span><span class="token punctuation">(</span><span class="token function">createDep</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>tigger函数的作用就是触发依赖，当我们修改数据的时候，就会触发依赖，然后执行依赖中的副作用函数。</p> <p>在这里的实现其实并没有执行，主要是收集一些需要执行的副作用函数，然后在丢给triggerEffects函数去执行。</p> <p><strong>triggerEffects</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">triggerEffects</span><span class="token punctuation">(</span>
  dep<span class="token operator">:</span> Dep <span class="token operator">|</span> ReactiveEffect<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  debuggerEventExtraInfo<span class="token operator">?</span><span class="token operator">:</span> DebuggerEventExtraInfo
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// spread into array for stabilization</span>
  <span class="token comment">// 如果 dep 不是数组，就会将 dep 转换成数组，因为这里的 dep 可能是一个 Set 对象</span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> <span class="token function">isArray</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token operator">?</span> dep <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>dep<span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> effect <span class="token keyword">of</span> effects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> debuggerEventExtraInfo<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 执行 computed 依赖</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> effect <span class="token keyword">of</span> effects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>effect<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> debuggerEventExtraInfo<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里没什么特殊的，就是转换一下dep，然后执行computed依赖和其他依赖，主要还是在triggerEffect函数：</p> <p><strong>triggerEffect</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">triggerEffect</span><span class="token punctuation">(</span>
  effect<span class="token operator">:</span> ReactiveEffect<span class="token punctuation">,</span>
  debuggerEventExtraInfo<span class="token operator">?</span><span class="token operator">:</span> DebuggerEventExtraInfo
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果 effect 不是 activeEffect，或者 effect 允许递归，就会执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>effect <span class="token operator">!==</span> activeEffect <span class="token operator">||</span> effect<span class="token punctuation">.</span>allowRecurse<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> effect<span class="token punctuation">.</span>onTrigger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effect<span class="token punctuation">.</span><span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> effect <span class="token punctuation">}</span><span class="token punctuation">,</span> debuggerEventExtraInfo<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果 effect 是一个调度器，就会执行 scheduler</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effect<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的 effect.scheduler和effect.run，在我们看effect函数的时候，就已经出现过了，run就是调用副作用函数，scheduler是调度器，允许用户自定义调用副作用函数的时机。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>整个响应式系统的实现，主要是围绕的effect函数，reactive函数，track函数，trigger函数这四个函数。</p> <p>每个函数都只做自己的事情，各司其职：</p> <ul><li>effect函数：创建一个副作用函数，主要的作用是来运行副作用函数</li> <li>reactive函数：创建一个响应式对象，主要的作用是来监听对象的变化</li> <li>track函数：依赖收集，主要收集的就是effect函数</li> <li>trigger函数：依赖触发，主要的作用是来触发track函数收集的effect函数</li></ul> <p>get中调用track函数收集activeEffect，这个时候activeEffect是一定存在的，并且activeEffect中的副作用函数是一定引用了这个响应式对象的，所以这个时候就可以将这个响应式对象和activeEffect关联起来。</p> <p>将当前的对象作为key，将activeEffect作为value，存储到targetMap中，这样就完成了依赖收集。</p> <p>在响应式对象的set钩子中，调用trigger函数，将targetMap中的activeEffect取出来，然后执行activeEffect的run函数，这样就完成了依赖触发。</p> <h4 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h4> <p><a href="https://segmentfault.com/a/1190000043507445#item-2-5" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000043507445#item-2-5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/studynotes/vueSourceCode/Vue3 源码解读之 teleport.html" class="prev">
        Vue3 源码解读之 teleport
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/studynotes/assets/js/app.3d955cb7.js" defer></script><script src="/studynotes/assets/js/2.007e39c9.js" defer></script><script src="/studynotes/assets/js/1.02c32e63.js" defer></script><script src="/studynotes/assets/js/27.f89d87c6.js" defer></script>
  </body>
</html>
